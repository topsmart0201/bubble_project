% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Fry_bubble.R
\name{jmf1MK}
\alias{jmf1MK}
\title{Log-likelihood for the univariate bubble model by Fry (2014) - second variant}
\usage{
jmf1MK(x, data)
}
\arguments{
\item{x}{is a 4 x 1 parameter vector}

\item{data}{is a (n-1) x 1 numeric data vector}
}
\value{
y a 1 x 1 scalar which is the log-likelihood
}
\description{
This function computes the second variant of the log-likelihood for the univariate bubble model by Fry (2014),
expressed in terms of the parameter "v"
}
\details{
This function computes the second variant of the log-likelihood for the univariate bubble model by Fry (2014).
The parameters vector consists of the following parameters:

  x[1]:      mean

  x[2]:      v = - ln[(1 - k)] > 0, where k percent is automatically wiped off
             the value of the asset in case of market crash

  x[3]:      sigma (variance)

  x[4]:      beta (from hazard function)
}
\examples{

 \dontrun{
 #Create data set with log-returns
 library(PerformanceAnalytics)
 library(numDeriv)
 path.bit=system.file("extdata", "coindesk-bpi-USD-close.csv", package = "bubble")

 #load data on bitcoin downloaded from coindesk:  http://www.coindesk.com/price/
 dat <- read.table(path.bit, dec = ".", sep =",", header = TRUE)
 dat2 <- subset(dat, as.numeric(Date) > 898 & as.numeric(Date) < 1233)
 row.names(dat2) <- levels(dat2$Date)[dat2$Date]
 dat3 <- dat2[, 'Close', drop=FALSE]

 #compute log-returns
 bitret <- CalculateReturns(dat3, method="log")
 bitret = bitret[-1,]
 plot(bitret)
 plot(cumsum(bitret))

#Optimize using good starting values
 mu <- mean(bitret)
startx.2 <- c(mu, 0.546, 0.007, 1.136)
result.2 <- optim(startx.2, jmf1MK, data=bitret, control=list(maxit=1000, fnscale=-1), hessian=TRUE)

#Compute Hessian and var/covar matrix
hess3 <- hessian(x=result.2$par, data=bitret, func=jmf1MK)
hess4 <- -solve(hess3) # variance-covariance matrix
hess4

#Estimates
mu.2.est <- result.2$par[1]
v.2.est <- result.2$par[2]
sigma.2.est <- result.2$par[3]
beta.2.est <- result.2$par[4]
alpha.2.est <- (v.2.est^2)/(sigma.2.est*(beta.2.est-1)^((1/beta.2.est)-1))

mu.tilda.2 <- round((mu.2.est + (1/2)*sigma.2.est), 5)
v.2 <- round(v.2.est,5)

#Standard deviations

stdev.mu.tilda.2 <- round(sqrt(hess4[1,1] + (1/4)*hess4[3,3] + hess4[1,3]),5)
stdev.v.2 <- round(sqrt(hess4[2,2]),3)
stdev.mu.tilda.2
stdev.v.2

#T-stats and p-values
t.mu.tilda <- (mu.2.est + (1/2)*sigma.2.est)/(sqrt(hess4[1,1] + (1/4)*hess4[3,3] + hess4[1,3]))
t.v <- v.2.est/(sqrt(hess4[2,2]))
t.mu.tilda.r <- round(t.mu.tilda,3)
t.v.r <- round(t.v,3)

pvalue.mu.tilda <- round(2*pt(t.mu.tilda, 329, lower.tail = FALSE),3)
pvalue.v <- round(2*pt(t.v, 329, lower.tail = FALSE),3)
pvalue.mu.tilda
pvalue.v

# Reproduce Table 2, p.35, by Cheah and Fry (2015)

DF.1 <- data.frame(Parameter=c("nu", "mu.tilda"),
                 Estimate=c(v.2, mu.tilda.2),
                  E.S.E.=c(stdev.v.2, stdev.mu.tilda.2),
                  "t-value"=c(t.v.r, t.mu.tilda.r),
                  "p-value"=c(pvalue.v, pvalue.mu.tilda)
                  )

DF.1

}
}
