% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Fry_bubble.R
\name{jmf1}
\alias{jmf1}
\title{Log-likelihood for the univariate bubble model by Fry (2014)}
\usage{
jmf1(x, data)
}
\arguments{
\item{x}{is a 4 x 1 parameter vector}

\item{data}{is a (n-1) x 1 numeric data vector}
}
\value{
y a 1 x 1 scalar which is the log-likelihood
}
\description{
This function computes the log-likelihood for the univariate bubble model by Fry (2014)
}
\details{
This function computes the log-likelihood for the univariate bubble model by Fry (2014).
The parameters vector consists of the following parameters:

  x[1]:      mean

  x[2]:      variance (sigma)

  x[3]:      alpha (from hazard function)

  x[4]:      beta (from hazard function)
}
\examples{

 \dontrun{
 #Create data set with log-returns
 library(PerformanceAnalytics)
 library(numDeriv)
 path.bit=system.file("extdata", "coindesk-bpi-USD-close.csv", package = "bubble")

 #load data on bitcoin downloaded from coindesk:  http://www.coindesk.com/price/
 dat <- read.table(path.bit, dec = ".", sep =",", header = TRUE)
 dat2 <- subset(dat, as.numeric(Date) > 898 & as.numeric(Date) < 1233)
 row.names(dat2) <- levels(dat2$Date)[dat2$Date]
 dat3 <- dat2[, 'Close', drop=FALSE]

 #compute log-returns
 bitret <- CalculateReturns(dat3, method="log")
 bitret = bitret[-1,]
 plot(bitret)
 plot(cumsum(bitret))

 #Set (good) starting values and optimize
 mu <- mean(bitret)
 n <- length(bitret)
 sigma <- sqrt(((n-1)/n)*var(bitret))
 startx.1 <- c(mu, sigma, 4, 4)
 result.1 <- optim(startx.1, jmf1, data=bitret,control=list(maxit=1000, fnscale=-1), hessian = TRUE)

 #Compute hessian and variance-covariance matrix
  hess <- hessian(x=result.1$par, data=bitret, func=jmf1)
  hess2 <- -solve(hess) # variance-covariance matrix
  hess2

 #Compute v and mu.tilde from estimated parameters and replicate
 #the parameter estimates of bubble model reported in Table 2, p.35, by Cheah and Fry (2015)
  mu.est <- result.1$par[1]; mu.est;
  sigma.est <- result.1$par[2]; sigma.est;
  alpha.est <- result.1$par[3]; alpha.est;
  beta.est <- result.1$par[4]; beta.est;

  v <- round((sqrt(sigma.est*alpha.est*(beta.est-1)^((1/beta.est)-1))),3)
  v
  mu.tilda <- round((mu.est + (1/2)*sigma.est), 5)
  mu.tilda

 }

}
